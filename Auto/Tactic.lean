import Lean
import Auto.Translation
import Auto.Solver.SMT
import Auto.Solver.TPTP
import Auto.Solver.Native
import Auto.HintDB
open Lean Elab Tactic

initialize
  registerTraceClass `auto.tactic
  registerTraceClass `auto.printLemmas

namespace Auto

syntax hintelem := term <|> "*"
syntax hints := ("[" hintelem,* "]")?
-- Must be topologically sorted, refer to `Lemma.unfoldConsts`
-- **TODO**: Automatically topological sort
syntax unfolds := ("u[" ident,* "]")?
syntax defeqs := ("d[" ident,* "]")?
syntax autoinstr := ("üëç" <|> "üëé")?
syntax (name := auto) "auto" autoinstr hints unfolds defeqs : tactic
syntax (name := mononative) "mononative" hints unfolds defeqs : tactic
syntax (name := intromono) "intromono" hints unfolds defeqs : tactic

inductive Instruction where
  | none
  | useSorry

def parseInstr : TSyntax ``Auto.autoinstr ‚Üí TacticM Instruction
| `(autoinstr|) => return .none
| `(autoinstr|üëç) => throwError "Your flattery is appreciated üòé"
| `(autoinstr|üëé) => do
  logInfo "I'm terribly sorry. A 'sorry' is sent to you as compensation."
  return .useSorry
| _ => throwUnsupportedSyntax

inductive HintElem where
  -- A user-provided term
  | term     : Term ‚Üí HintElem
  -- Hint database, not yet supported
  | hintdb   : HintElem
  -- `*` adds all hypotheses in the local context
  -- Also, if `[..]` is not supplied to `auto`, all
  --   hypotheses in the local context are
  --   automatically collected.
  | lctxhyps : HintElem
deriving Inhabited, BEq

def parseHintElem : TSyntax ``hintelem ‚Üí TacticM HintElem
| `(hintelem| *)       => return .lctxhyps
| `(hintelem| $t:term) => return .term t
| _ => throwUnsupportedSyntax

structure InputHints where
  terms    : Array Term := #[]
  hintdbs  : Array Unit := #[]
  lctxhyps : Bool       := false
deriving Inhabited, BEq

/-- Parse `hints` to an array of `Term`, which is still syntax -/
def parseHints : TSyntax ``hints ‚Üí TacticM InputHints
| `(hints| [ $[$hs],* ]) => do
  let mut terms := #[]
  let mut lctxhyps := false
  let elems ‚Üê hs.mapM parseHintElem
  for elem in elems do
    match elem with
    | .term t => terms := terms.push t
    | .lctxhyps => lctxhyps := true
    | _ => throwError "parseHints :: Not implemented"
  return ‚ü®terms, #[], lctxhyps‚ü©
| `(hints| ) => return ‚ü®#[], #[], true‚ü©
| _ => throwUnsupportedSyntax

private def defeqUnfoldErrHint :=
  "Note that auto does not accept defeq/unfold hints which" ++
  "are let-declarations in the local context, because " ++
  "let-declarations are automatically unfolded by auto."

def parseUnfolds : TSyntax ``unfolds ‚Üí TacticM (Array Prep.ConstUnfoldInfo)
| `(unfolds| u[ $[$hs],* ]) => do
  let exprs ‚Üê hs.mapM (fun i => do
    let some expr ‚Üê Term.resolveId? i
      | throwError "parseUnfolds :: Unknown identifier {i}. {defeqUnfoldErrHint}"
    return expr)
  exprs.mapM (fun expr => do
    let some name := expr.constName?
      | throwError "parseUnfolds :: Unknown declaration {expr}. {defeqUnfoldErrHint}"
    Prep.getConstUnfoldInfo name)
| `(unfolds|) => pure #[]
| _ => throwUnsupportedSyntax

def parseDefeqs : TSyntax ``defeqs ‚Üí TacticM (Array Name)
| `(defeqs| d[ $[$hs],* ]) => do
  let exprs ‚Üê hs.mapM (fun i => do
    let some expr ‚Üê Term.resolveId? i
      | throwError "parseDefeqs :: Unknown identifier {i}. {defeqUnfoldErrHint}"
    return expr)
  exprs.mapM (fun expr => do
    let some name := expr.constName?
      | throwError "parseDefeqs :: Unknown declaration {expr}. {defeqUnfoldErrHint}"
    return name)
| `(defeqs|) => pure #[]
| _ => throwUnsupportedSyntax

def collectLctxLemmas (lctxhyps : Bool) (ngoalAndBinders : Array FVarId) : TacticM (Array Lemma) :=
  Meta.withNewMCtxDepth do
    let fVarIds := (if lctxhyps then (‚Üê getLCtx).getFVarIds else ngoalAndBinders)
    let mut lemmas := #[]
    for fVarId in fVarIds do
      let decl ‚Üê FVarId.getDecl fVarId
      if ¬¨ decl.isAuxDecl ‚àß (‚Üê Meta.isProp decl.type) then
        lemmas := lemmas.push ‚ü®mkFVar fVarId, ‚Üê instantiateMVars decl.type, #[]‚ü©
    return lemmas

def collectUserLemmas (terms : Array Term) : TacticM (Array Lemma) :=
  Meta.withNewMCtxDepth do
    let mut lemmas := #[]
    for ‚ü®proof, type, params‚ü© in ‚Üê terms.mapM Prep.elabLemma do
      if ‚Üê Meta.isProp type then
        lemmas := lemmas.push ‚ü®proof, ‚Üê instantiateMVars type, params‚ü©
      else
        -- **TODO**: Relax condition?
        throwError "invalid lemma {type} for auto, proposition expected"
    return lemmas

def collectDefeqLemmas (names : Array Name) : TacticM (Array Lemma) :=
  Meta.withNewMCtxDepth do
    let lemmas ‚Üê names.concatMapM Prep.elabDefEq
    lemmas.mapM (fun (‚ü®proof, type, params‚ü© : Lemma) => do
      let type ‚Üê instantiateMVars type
      return ‚ü®proof, type, params‚ü©)

def unfoldConstAndPreprocessLemma (unfolds : Array Prep.ConstUnfoldInfo) (lem : Lemma) : MetaM Lemma := do
  let type ‚Üê prepReduceExpr (‚Üê instantiateMVars lem.type)
  let type := Prep.unfoldConsts unfolds type
  let type ‚Üê Core.betaReduce (‚Üê instantiateMVars type)
  let lem := {lem with type := type}
  let lem ‚Üê lem.reorderForallInstDep
  return lem

/--
  We assume that all defeq facts have the form
    `‚àÄ (x‚ÇÅ : ‚ãØ) ‚ãØ (x‚Çô : ‚ãØ), c ... = ...`
  where `c` is a constant. To avoid `whnf` from reducing
  `c`, we call `forallTelescope`, then call `prepReduceExpr`
  on
  ¬∑ All the arguments of `c`, and
  ¬∑ The right-hand side of the equation
-/
def unfoldConstAndprepReduceDefeq (unfolds : Array Prep.ConstUnfoldInfo) (lem : Lemma) : MetaM Lemma := do
  let .some type ‚Üê prepReduceDefeq (‚Üê instantiateMVars lem.type)
    | throwError "unfoldConstAndprepReduceDefeq :: Unrecognized definitional equation {lem.type}"
  let type := Prep.unfoldConsts unfolds type
  let type ‚Üê Core.betaReduce (‚Üê instantiateMVars type)
  let lem := {lem with type := type}
  let lem ‚Üê lem.reorderForallInstDep
  return lem

def traceLemmas (pre : String) (lemmas : Array Lemma) : TacticM Unit := do
  let mut cnt : Nat := 0
  let mut mdatas : Array MessageData := #[]
  for lem in lemmas do
    mdatas := mdatas.push m!"\n{cnt}: {lem}"
    cnt := cnt + 1
  trace[auto.printLemmas] mdatas.foldl MessageData.compose pre

def checkDuplicatedFact (terms : Array Term) : TacticM Unit :=
  let n := terms.size
  for i in [0:n] do
    for j in [i+1:n] do
      if terms[i]? == terms[j]? then
        throwError "Auto does not accept duplicated input terms"

def collectAllLemmas (hintstx : TSyntax ``hints) (unfolds : TSyntax `Auto.unfolds)
  (defeqs : TSyntax `Auto.defeqs) (ngoalAndBinders : Array FVarId) :
  -- The first `Array Lemma` are `Prop` lemmas
  -- The second `Array Lemma` are Inhabitation facts
  TacticM (Array Lemma √ó Array Lemma) := do
  let inputHints ‚Üê parseHints hintstx
  let unfoldInfos ‚Üê parseUnfolds unfolds
  let defeqNames ‚Üê parseDefeqs defeqs
  let startTime ‚Üê IO.monoMsNow
  let lctxLemmas ‚Üê collectLctxLemmas inputHints.lctxhyps ngoalAndBinders
  let lctxLemmas ‚Üê lctxLemmas.mapM (m:=MetaM) (unfoldConstAndPreprocessLemma unfoldInfos)
  traceLemmas "Lemmas collected from local context:" lctxLemmas
  checkDuplicatedFact inputHints.terms
  let userLemmas ‚Üê collectUserLemmas inputHints.terms
  let userLemmas ‚Üê userLemmas.mapM (m:=MetaM) (unfoldConstAndPreprocessLemma unfoldInfos)
  traceLemmas "Lemmas collected from user-provided terms:" userLemmas
  let defeqLemmas ‚Üê collectDefeqLemmas defeqNames
  let defeqLemmas ‚Üê defeqLemmas.mapM (m:=MetaM) (unfoldConstAndprepReduceDefeq unfoldInfos)
  traceLemmas "Lemmas collected from user-provided defeq hints:" defeqLemmas
  trace[auto.tactic] "Preprocessing took {(‚Üê IO.monoMsNow) - startTime}ms"
  let inhFacts ‚Üê Inhabitation.getInhFactsFromLCtx
  let inhFacts ‚Üê inhFacts.mapM (m:=MetaM) (unfoldConstAndPreprocessLemma unfoldInfos)
  traceLemmas "Inhabitation lemmas :" inhFacts
  return (lctxLemmas ++ userLemmas ++ defeqLemmas, inhFacts)

/-- `ngoal` means `negated goal` -/
def runAuto (instrstx : TSyntax ``autoinstr) (lemmas : Array Lemma) (inhFacts : Array Lemma) : TacticM Expr := do
  let instr ‚Üê parseInstr instrstx
  let declName? ‚Üê Elab.Term.getDeclName?
  -- Simplify `ite`
  let ite_simp_lem ‚Üê Lemma.ofConst ``Auto.Bool.ite_simp
  let lemmas ‚Üê lemmas.mapM (fun lem => Lemma.rewriteUPolyRigid lem ite_simp_lem)
  -- Simplify `decide`
  let decide_simp_lem ‚Üê Lemma.ofConst ``Auto.Bool.decide_simp
  let lemmas ‚Üê lemmas.mapM (fun lem => Lemma.rewriteUPolyRigid lem decide_simp_lem)
  match instr with
  | .none =>
    let afterReify (uvalids : Array UMonoFact) (uinhs : Array UMonoFact) (minds : Array (Array SimpleIndVal)) : LamReif.ReifM Expr := (do
      let exportFacts ‚Üê LamReif.reifFacts uvalids
      let exportFacts := exportFacts.map (Embedding.Lam.REntry.valid [])
      let _ ‚Üê LamReif.reifInhabitations uinhs
      let exportInhs := (‚Üê LamReif.getRst).nonemptyMap.toArray.map
        (fun (s, _) => Embedding.Lam.REntry.nonempty s)
      let exportInds ‚Üê LamReif.reifMutInds minds
      -- **Preprocessing in Verified Checker**
      let (exportFacts, exportInds) ‚Üê LamReif.preprocess exportFacts exportInds
      -- **TPTP**
      if (auto.tptp.get (‚Üê getOptions)) then
        if let .some proof ‚Üê queryTPTP exportFacts then
          return proof
      -- **SMT**
      if (auto.smt.get (‚Üê getOptions)) then
        if let .some proof ‚Üê querySMT exportFacts exportInds then
          return proof
      -- **Native Prover**
      let exportFacts := exportFacts.append (‚Üê LamReif.auxLemmas exportFacts)
      if (auto.native.get (‚Üê getOptions)) then
        if let .some proof ‚Üê queryNative declName? exportFacts exportInhs then
          return proof
      throwError "Auto failed to find proof"
      )
    let (proof, _) ‚Üê Monomorphization.monomorphize lemmas inhFacts (@id (Reif.ReifM Expr) do
      let uvalids ‚Üê liftM <| Reif.getFacts
      let uinhs ‚Üê liftM <| Reif.getInhTys
      let inds ‚Üê liftM <| Reif.getInds
      let u ‚Üê computeMaxLevel uvalids
      (afterReify uvalids uinhs inds).run' {u := u})
    trace[auto.tactic] "Auto found proof of {‚Üê Meta.inferType proof}"
    return proof
  | .useSorry => return ‚Üê Meta.mkAppM ``sorryAx #[Expr.const ``False [], Expr.const ``false []]
where
  queryTPTP exportFacts : LamReif.ReifM (Option Expr) :=
    try
      let lamVarTy := (‚Üê LamReif.getVarVal).map Prod.snd
      let lamEVarTy ‚Üê LamReif.getLamEVarTy
      let exportLamTerms ‚Üê exportFacts.mapM (fun re => do
        match re with
        | .valid [] t => return t
        | _ => throwError "runAuto :: Unexpected error")
      let query ‚Üê lam2TH0 lamVarTy lamEVarTy exportLamTerms
      trace[auto.tptp.printQuery] "\n{query}"
      let tptpProof ‚Üê Solver.TPTP.querySolver query
      let proofSteps ‚Üê Parser.TPTP.getProof (‚Üê LamReif.getLamTyValAtMeta) tptpProof
      for step in proofSteps do
        trace[auto.tptp.printProof] "{step}"
      return .none
    catch e =>
      trace[auto.tptp.result] "TPTP invocation failed with {e.toMessageData}"
      return .none
  querySMT exportFacts exportInds : LamReif.ReifM (Option Expr) :=
    try
      let lamVarTy := (‚Üê LamReif.getVarVal).map Prod.snd
      let lamEVarTy ‚Üê LamReif.getLamEVarTy
      let exportLamTerms ‚Üê exportFacts.mapM (fun re => do
        match re with
        | .valid [] t => return t
        | _ => throwError "runAuto :: Unexpected error")
      let commands ‚Üê (lamFOL2SMT lamVarTy lamEVarTy exportLamTerms exportInds).run'
      for cmd in commands do
        trace[auto.smt.printCommands] "{cmd}"
      let .some _ ‚Üê Solver.SMT.querySolver commands
        | return .none
      if (auto.smt.trust.get (‚Üê getOptions)) then
        logWarning "Trusting SMT solvers. `autoSMTSorry` is used to discharge the goal."
        return .some (‚Üê Meta.mkAppM ``Solver.SMT.autoSMTSorry #[Expr.const ``False []])
      else
        return .none
    catch e =>
      trace[auto.smt.result] "SMT invocation failed with {e.toMessageData}"
      return .none
  queryNative declName? exportFacts exportInhs : LamReif.ReifM (Option Expr) := do
    try
      let (proof, proofLamTerm, usedEtoms, usedInhs, unsatCore) ‚Üê
        Lam2D.callNative_checker exportInhs exportFacts Solver.Native.queryNative
      LamReif.newAssertion proof proofLamTerm
      let etomInstantiated ‚Üê LamReif.validOfInstantiateForall (.valid [] proofLamTerm) (usedEtoms.map .etom)
      let forallElimed ‚Üê LamReif.validOfElimForalls etomInstantiated usedInhs
      let contra ‚Üê LamReif.validOfImps forallElimed unsatCore
      LamReif.printValuation
      LamReif.printProofs
      Reif.setDeclName? declName?
      let checker ‚Üê LamReif.buildCheckerExprFor contra
      let contra ‚Üê Meta.mkAppM ``Embedding.Lam.LamThmValid.getFalse #[checker]
      let proof ‚Üê Meta.mkLetFVars ((‚Üê Reif.getFvarsToAbstract).map Expr.fvar) contra
      return .some proof
    catch e =>
      trace[auto.tactic] "Native prover invocation failed with {e.toMessageData}"
      return .none

@[tactic auto]
def evalAuto : Tactic
| `(auto | auto $instr $hints $unfolds $defeqs) => withMainContext do
  let startTime ‚Üê IO.monoMsNow
  -- Suppose the goal is `‚àÄ (x‚ÇÅ x‚ÇÇ ‚ãØ x‚Çô), G`
  -- First, apply `intros` to put `x‚ÇÅ x‚ÇÇ ‚ãØ x‚Çô` into the local context,
  --   now the goal is just `G`
  let (goalBinders, newGoal) ‚Üê (‚Üê getMainGoal).intros
  let [nngoal] ‚Üê newGoal.apply (.const ``Classical.byContradiction [])
    | throwError "evalAuto :: Unexpected result after applying Classical.byContradiction"
  let (ngoal, absurd) ‚Üê MVarId.intro1 nngoal
  replaceMainGoal [absurd]
  withMainContext do
    let (lemmas, inhFacts) ‚Üê collectAllLemmas hints unfolds defeqs (goalBinders.push ngoal)
    let proof ‚Üê runAuto instr lemmas inhFacts
    IO.println s!"Auto found proof. Time spent by auto : {(‚Üê IO.monoMsNow) - startTime}ms"
    absurd.assign proof
| _ => throwUnsupportedSyntax

@[tactic intromono]
def evalIntromono : Tactic
| `(intromono | intromono $hints $unfolds $defeqs) => withMainContext do
  let (goalBinders, newGoal) ‚Üê (‚Üê getMainGoal).intros
  let [nngoal] ‚Üê newGoal.apply (.const ``Classical.byContradiction [])
    | throwError "evalAuto :: Unexpected result after applying Classical.byContradiction"
  let (ngoal, absurd) ‚Üê MVarId.intro1 nngoal
  replaceMainGoal [absurd]
  withMainContext do
    let (lemmas, _) ‚Üê collectAllLemmas hints unfolds defeqs (goalBinders.push ngoal)
    let newMid ‚Üê Monomorphization.intromono lemmas absurd
    replaceMainGoal [newMid]
| _ => throwUnsupportedSyntax

/--
  A monomorphization interface that can be invoked by repos dependent
    on `lean-auto`.
-/
def monoInterface
  (lemmas : Array Lemma) (inhFacts : Array Lemma)
  (prover : Array Lemma ‚Üí MetaM Expr) : MetaM Expr := do
  let afterReify (uvalids : Array UMonoFact) (uinhs : Array UMonoFact) : LamReif.ReifM Expr := (do
    let exportFacts ‚Üê LamReif.reifFacts uvalids
    let exportFacts := exportFacts.map (Embedding.Lam.REntry.valid [])
    let _ ‚Üê LamReif.reifInhabitations uinhs
    let exportInhs := (‚Üê LamReif.getRst).nonemptyMap.toArray.map
      (fun (s, _) => Embedding.Lam.REntry.nonempty s)
    let proof ‚Üê Lam2D.callNative_direct exportInhs exportFacts prover
    Meta.mkLetFVars ((‚Üê Reif.getFvarsToAbstract).map Expr.fvar) proof)
  let (proof, _) ‚Üê Monomorphization.monomorphize lemmas inhFacts (@id (Reif.ReifM Expr) do
    let uvalids ‚Üê liftM <| Reif.getFacts
    let uinhs ‚Üê liftM <| Reif.getInhTys
    let u ‚Üê computeMaxLevel uvalids
    (afterReify uvalids uinhs).run' {u := u})
  return proof

@[tactic mononative]
def evalMonoNative : Tactic
| `(mononative | mononative $hints $unfolds $defeqs) => withMainContext do
  let startTime ‚Üê IO.monoMsNow
  -- Suppose the goal is `‚àÄ (x‚ÇÅ x‚ÇÇ ‚ãØ x‚Çô), G`
  -- First, apply `intros` to put `x‚ÇÅ x‚ÇÇ ‚ãØ x‚Çô` into the local context,
  --   now the goal is just `G`
  let (goalBinders, newGoal) ‚Üê (‚Üê getMainGoal).intros
  let [nngoal] ‚Üê newGoal.apply (.const ``Classical.byContradiction [])
    | throwError "evalAuto :: Unexpected result after applying Classical.byContradiction"
  let (ngoal, absurd) ‚Üê MVarId.intro1 nngoal
  replaceMainGoal [absurd]
  withMainContext do
    let (lemmas, inhFacts) ‚Üê collectAllLemmas hints unfolds defeqs (goalBinders.push ngoal)
    let proof ‚Üê monoInterface lemmas inhFacts Solver.Native.queryNative
    IO.println s!"Auto found proof. Time spent by auto : {(‚Üê IO.monoMsNow) - startTime}ms"
    absurd.assign proof
| _ => throwUnsupportedSyntax

end Auto
